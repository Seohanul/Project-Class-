cp 10 소켓 입출력 

12월 첫째주가 조기검사



--------


소켓모드
	블로킹, 넌블로킹

	

블로킹 소켓
	소켓 함수 호출 시 조건에 만족되지 않으면 함수가 리턴하지 않고 *스레드 실행이 정지*

	조건이 만족되면 소켓 함수가 리턴하면서 정지된 스레드가 깨어나 실행르 재개

	send() , 송신버퍼에 충분한 여유공간이 있는가?
	
	recv() 수신 버퍼에 도착한 데이터가 1바이트라도 있으면 조건 만족
		다 받을때까지 기다리는거는 recvn 쓰는거

넌블로킹 소켓
	소켓 함수 호출 시 조건에 만족되지 않아도 스레드 중단x , 일단 리턴

	

// 블로킹 소켓 생성
	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	if(sock == INVALID_SOCKET) err_quit("socket()");

// 넌블로킹 소켓으로 전환
	u_long on = 1;
	retval = ioctlsocket(sock, FIONBIO, &on);
	if(retval == SOCKET_ERROR) err_quit("ioctlsocket()");


WSAGetLastError() 함수를 꼭 이용해서 오류 코드 확인해야함

	대개 오류 코드는 WSAEWOULDBLOCK
	조건이 만족되지 않았음을 나타내므로 나중에 다시 소켓 함수를 호출하면 됨




넌블로킹 장점
	교착상태 x

 단점
	오류 코드 확인 후 처리해야하므로 구조 복잡
	
	블로킹보다는 cpu사용률이 높다 (애매함, 장점이 될수도있음)
	





반복 서버 (UDP에 적합)
	여러 클라이언트를 한번에 하나씩 처리
	장점 : 스레드 한개, 시스템 자원 소모 적음
	단점 : 한클라이언트 처리 시간이 길어지면 다른애들 대기시간 길어짐


병행 서버 (TCP에 적합)
	여러 클라이언트를 동시에 처리
	장점: 한 클라 처리 시간이 다른 클라에 영향 x
	단점: 스레드 여러개, 시스템 자원 소모 많음







이상적인 소켓 입출력 모델의 특징

~

** CPU 명령 수행과 입출력 작업을 병행 ***
	IO는 매우 느리기때문에 그걸 cpu가 기다리고 있으면 너무 낭비임

유저모드와 커널모드 전환 횟수를 최소화







Select 모델

	select() 함수가 핵심 역할을 함

	소켓 모드(블로킹, 넌블로킹)와 관계없이 여러 소켓을 한 스레드로 처리 가능하게 해줌
			소켓 64개를 하나의 스레드에서 처리하게 해줌
	
	핵심 원리
		소켓 함수 호출이 성공할 수 있는 시점을 미리 알 수 있어서 소켓 함수 호출 시 조건이 만족되지 않아 생기는 문제를 해결할 수 있음
		블로킹 소켓 : 소켓 함수 호출 시 조건이 만족되지않아 블로킹되는 상황을 방지
		넌블로킹 소켓 : 소켓 함수 호출 시 조건이 만족되지 않아 나중에 다시 호출해야 하는 상황을 방지




	동작 원리

	읽기 set, 쓰기 set, 예외 set 
	
	대상 소켓을 넣어줌

	예를 들어서.. recv를 하려고할때
	
	바로 리턴할 수 있도록

	select를 먼저 보내서 select가 수신 버퍼 확인

	select가 리턴되면 그때 recv 호출 하는식 (실패할 일이 없음)





int select (
	int nfds,
	fd_set *readfds,
	fd_set *writefds,
	fd_set *exceptfds,
	const struct timeval *timeout
) ;
	성공: 조건을 만족하는 소켓의 개수 또는 0(타임아웃),
	실패: SOCKET_ERROR
		


select() 함수를 이용한 소켓 입출력 절차

	1. 소켓 set을 비움 (초기화)

	2. 소켓 셋에 소켓을 넣음. 넣을 수 있는 최대는 64로 세팅되있음

	3. select()함수 호출, 타임아웃이 NULL이면 만족하는 소켓 있을때까지 리턴x

	4. select() 함수가 리턴하면 소켓 셋에 남아 있는 모든 소켓에 대해 적절한 소켓 함수를 호출하여 처리










