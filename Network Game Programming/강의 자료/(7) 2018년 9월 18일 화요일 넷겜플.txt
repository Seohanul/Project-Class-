4장 

추석 보강 12월 11일

한글날 보강
10월 2일 화요일 

중간고사ㅣ 10월 18일 목
10월 16일 화 휴강


10월 23일 팀 구성 

계획서 리뷰, 메모는 가능 사진 x, 필기구 필요


10월 30일  계획서 검사

통과 -> 바로 개발
조건 부 통과, fail -> 다시 계획서 


12월 11일 최종 검사날
		미리 검사 받으면 가산점 


-----------------------------------------------------------------------


ppt
11p


소켓 통신을 위해 결정해야 할 요소 (개발자가 결정)
	1. 프로토콜
		통신 규약 소켓을 생성할때 결정

	2. 지역 IP 주소와 지역 포트번호 (알아야할 사항) (내꺼)
		서버 또는 클라이언트 자신의 주소

	3. 원격 IP주소와 원격 포트번호 (알아야할 사항) (상대방꺼)
		서버 또는 클라이언트가 통신하는 상대의 주소

		지역, 원격은 상대적인 개념
		서버는 로컬 클라이언트는 리모트 이런거아님
		내가 서버면 서버가 로컬 클라가 리모트
		내가 클라면 클라가 로컬 서버가 리모트


게임 아이콘을 다운받을때 서버의 IP와 포트번호를 같이 가져온거임

다음에 게임에 접속하려고 할때는 그 아이콘을 더블 클릭만하면 실행이됨

게임 서버들도 IP랑 포트번호 바꿀텐데 어떻게 반영??

실제 아이콘에 있는건 실제 데이터가 아니고 실제 데이터에 접근할 수 있는 번호 




실습 3장꺼 도메인 넣으면 IP 바뀌는데 그 이유는 ??

	IP가 안바뀌면 해커들이 거기에다 매크로 때림 (보안상의 문제)	
		









TCP 서버 함수


	TCP 서버							TCP 클라이언트
	socket() 대기 소켓생성. 사용할 프로토콜 결정

	bind()	묶어주는거, 대기소켓과 서버의 주소정보 묶어줌
		지역 IP/port 번호 결정

	listen() TCP를 LISTENING 상태로 변경
		(이때부터 클라이언트 요청 처리가능)

	
	accept() 자신에게 접속한 클라이언트와 통신을 수행
		원격 IP/ port 번호 결정
		전용소켓을 하나 만들어줌 
		(대기 소켓의 클라이언트 데이터를 옮겨줄 소켓)
		

	closesocket() 이건 대기소켓이 아닌 전용소켓을 닫아주는 함수

			서버를 닫을때는 대기 소켓도 닫아줘야함






	* bind()
	int bind (
		SOCKET s,
		const struct sockaddr *name,
		int namelen
	);
	성공 0, 실패 : SOCKET_ERROR

	s : 대기소켓
	name: 소켓 주소 구조체를 지역 IP 주소와 지역 포트 번호로 초기화 하여 전달

	


	INADDR_ANY 0 임
	이렇게 쓰는이유 	
	서버의 IP 주소는 변할 수 있음
	0으로 하는 이유는 IP 주소가 변해도 모두 받을 수 있도록
	운영체제가 넘겨준 값을 사용







	int listen (
		SOCKET s,
		int backlog
	) ;
	성공: 0, 실패: SOCKET_ERROR

	s: 대기소켓
	backlog: 접속 가능한 클라이언트 개수
		

	SOMAXCONN
		위의 	INADDR_ANY 와 똑같은 기능




*accept
	접속한 클라이언트와 통신할 수 있도록 새로운 소켓을 생성해서 리턴
	접속한 클라이언트의 IP주소와 포트번호를 새로운 소켓에 알려줌

	SOCKET accept (
		SOCKET s,
		struct sockaddr *addr,
		int *addrlen
	) ;
성공: 새로운 소켓, 실패: INVALID_SOCKET


	s : 대기 소켓
	addr : 새로운 소켓 주소 구조체
	addrlen : 구조체의 크기



성공하면 client_sock이 만들어지고 clientaddr에 클라이언트의 IP주소와 포트번호가 들어감 (궁굼하면 출력해보면됨)

printf는 많이 쓰는게 좋음 (콘솔에 출력해도 좋고, 로그 파일을 새로 만들어도 좋고)

통신하고

할거 없으면 종료






-----------

TCP 클라이언트 함수

connect()
	TCP 프로토콜 수준에서 서버와 논리적 연결을 설정



	int connect (
		SOCKET s,
		const struct sockaddr *name,
		int namelen
	) ;
	성공: 0, 실패: SOCKET_ERROR	


	s : 클라이언트가 만든 소켓
	name : 소켓 주소 구조체를 서버 주소로 초기화하여 전달
	namelen : 구조체 길이


connect 함수 자체가 bind 함수 역할을 같이함
따로 bind를 부르지 않아도 클라이언트의 IP 주소와 포트번호가 같이 딸려서 감

	



*send()
	응용 프로그램 데이터를 운영체제의 송신 버퍼에 복사함으로써 데이터를 전송


	int send (
		SOCKET s,
		const char *buf,
		int len,
		int flags
	);
성공: 보낸 바이트 수, 실패: SOCKET_ERROR


운영체제는 송신버퍼와 수신버퍼를 가지고 있음

send함수를 보내고 리턴을 했다 라는 뜻은 상대방이 데이터를 받았다 라는 뜻이아니고

내가 보낸 데이터가 내 컴퓨터의 송신버퍼에 복사가 되었다 라는 얘기

송신 버퍼의 데이터는 운영체제가 정할때 나가는거임 (내가 정하는게 아님)

그냥 담아 놓기만 하는거임



송신버퍼에서 쐈는데 만약 데이터가 깨진다면?

TCP에서는 재전송을 요구함. 누가? 운영체제가 

서버의 운영체제가 재전송을 요구 -> 클라이언트 운영체제가 재전송

즉, 받는 쪽에서 받았다고 확인을 할때까지는 송신버퍼에 데이터가 남아 있어야함 **



블로킹 소켓 (기본적인 소켓)
	10바이트의 데이터를 보내려고 할때 송신버퍼에 5바이트 밖에 없으면
	송신버퍼에 공간이 나올때까지 기다림
	나중에 다시 설명 




TCP는 데이터의 경계구분을 안해

	내가 10바이트의 데이터를 송신버퍼에 저장했는데
	이게 한번에 간다는 보장이 없음. 쪼개져서 갈 수 있음
	recv함수도 반복해서 불러야함 (but, 데이터의 크기를 알아야함)
	그래서 recvn을 사용
	데이터가 작으면 상관없는데 데이터가 커지거나 네트워크의 거리가 멀거나 하면 나눠질 가능성이 큼
	그래서 데이터의 크기를 안다면 recvn을 사용하는게 정석




	int send (
		SOCKET s,
		const char *buf,
		int len,
		int flags
	);
성공: 보낸 바이트 수, 실패: SOCKET_ERROR
	

	s : 통신할 대상과 연결된 소켓
	buf : 보낼 데이터를 담고 있는 응용프로그램의 버퍼 주소
	len : 보낼 데이터의 크기
	flags : send() 함수의 동작을 바꾸는 옵션. 대부분 0 사용



보낼때는 기본적으로 블로킹 소켓이므로 쪼개져서 들어갈 걱정은 안해도됨 (나중에는 모름)



* recv()


	int recv (
		SOCKET s,
		char *buf,
		int len,
		int flags
	);
성공: 받은 바이트 수 또는 0(연결 종료시)
실패: SOCKET_ERROR



recvn 



연습문제 4-8
포트스캔

IP주소 넣고 포트 번호 범위를 넣으면

그 포트 번호가 가용한지 알아내는 것


