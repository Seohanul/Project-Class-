6장

멀티쓰레드


TCP 서버 클라이언트의 문제점

	1. 동시에 둘 이상의 클라이언트 서비스 불가 

		
	** 해결책

		1. 서버가 각 클라이언트와 통신하는 시간을 짧게 줄임
			장점 : 구현이 쉬움, 가장 적은 시스템 자원 사용
			단점 : 각 클라이언트의 처리 지연 시간이 길어질 수 있음
				게임이 안됨	
				
			
		2. 각 클라이언트를 스레드를 이용해 독립적으로 처리 ***
			소켓마다 스레드 하나 만들고 스레드 안에서 데이터 주고받는 일들을 해줌
			그러면 OS가 알아서 해줌 
			장점 : 소켓 입출력 모델에 비해 구현이 쉬움
			단점 : 가장 많은 시스템 자원 사용
				스레드 하나 만들때마다 메모리를 할당해줘야함 (1mb)

		3. 소켓 입출력 모델 사용(10 ~ 11장) 서버프로그래밍때 더 배울거 , iocp
			윈도우가 자원을 조금 덜 쓰고도 쓰레드를 운영할 수 있게 해주는 테크닉 (입출력모델)
			스레드하나에서 클라이언트 여러개 처리할 수 있게 방법을 제공해주는
			- 장점 : 소수의 스레드를 이용해 다수의 클라이언트를 처리
				-> 상대적으로 적은 시스템 자원 사용
			- 단점 : 구현이 어려움 
				2번 할 줄 알면서 2번의 단점을 보완하는 차원에서 입출력모델을 적재적소에 잘쓸 수 있을때 구현가능 


	텀프로젝트도 2번으로 하는게 좋음
	굳이 클라이언트가 얼마없는데 할필요도없고 이번엔 잘 안배울거






	문제 2 : 교착 상태 발생 가능성
		deadlock
		send와 recv 함수의 호출 순서가 서로 맞아야함.

		양쪽에서 recv 함수를 호출하면 교착상태 발생 

	
	해결책
		1.데이터 송수신 부분 잘 설계하기
			장점 : 특별한 기법 없이 곧바로 구현 가능
			단점 : 해결책은 아님 당연히 이래야하는거

		2. 소켓에 타임아웃 옵션 적용하기(8장)
			장점 : 구현이 쉬움
			단점 : 다른 방법에 비해 성능이 낮음 (몇초동안 일단 기다려야하니까)
				활용도 높지않음

		3. 넌블로킹 소켓 사용하기(10장) **
			소켓은 기본적으로 블로킹 소켓임 (샌드 리시브가 조건이 만족할때까지 기다림)
			샌드 함수는 송신버퍼에 여유공간이 있을때까지 기다림
			리시브 함수는 수신버퍼에 데이터가 들어올때까지 기다림
			넌블로킹으로 하면 이런 조건을 안맞춤
			만약 샌드할때 보낼 데이터가 10바이트인데 송신버퍼가 5바이트가 남았으면
			그냥 5바이트만 보냄
			못보낸 5바이트는 나중에 샌드로 다시 보내줘야함
			
			장점 : 근본적으로 교착 상태 해결
			단점 : 구현이 복잡(나중에 또 해야하니까), 시스템 자원(특히 CPU시간) 낭비


		4. 소켓 입출력 모델 사용 (10~ 11장)***
			장점 : 넌블로킹 소켓의 단점을 보완 & 교착상태 해결
			단점 : 첫번째나 두번째 해결책보다 구현이 어려움
			결국 이걸 알아야함 나중에 배울거




	* 프로세스
		운영체제가 코드, 데이터 , 리소스를 파일에서 읽어서 메모리 영역에 올려놓는 컨테이너 (정적인 개념)

	* 스레드
		CPU 시간을 할당받아 프로세스 메모리 영역에 있는 코드를 실제로 수행하고 데이터를 사용하는 동적인 개념

	* 주 스레드 , 메인 스레드
		응용 프로그램 실행시 최초로 생성되는 스레드
		main() 찍으면 실행




스케줄링 (스레드의 우선순위를 정해주는 일)

스레드를 실행하다가 중단하고 다른 스레드로 넘어갈때 저장해놔야하므로 메모리가 필요
	컨텍스트 스위치
	레지스터를 두고 결과를 저장하고 결과를 읽어오고

 



스레드 생성에 필요한 요소
	스레드 함수의 시작 주소
	
	스레드 함수 실행 시 사용할 스택의 크기




CreateThread() 

	첫인자 는 NULL 신경꺼
	두번째인자 	스레드에 할당되는 스택 크기 , 0 넣으면 1메가바이트
	세번째 인자 	스레드 함수 시작 주소
	네번째 인자 	스레드 함수의 인자값
	인자5 		0 또는 CREATE_SUSPENDED , 0을 넣으면 스레드를 생성하고 바로 스레드 시간 할당
						뒤에꺼 나오면 생성만하고 cpu시간은 나중에 할당 (내가 지시할때, ResumeThread함수)
	인자6 		스레드ID, 스레드 구분하고 싶을때, 필요없다 하면 null 넣으면 됨

HANDLE hThread = CreateThread(NULL, 0, ProcessClient, (LPVOID)client_sock, 0, NULL);

DWORD WINAPI ThreadProc(LPVOID lpParameter)
{
...
}

스레드 종료 방법

	1. 스레드 함수가 리턴
	2. 스레스 함수 내에서 ExitThread()
	3. 다른 스레드가 TerminateThread(), 핸들값 필요 ++  
	4. 주 스레드가 종료하면 모든 스레드 종료
	
	1,2 번 주로 사용 3번은 반드시 필요할때만 사용




	