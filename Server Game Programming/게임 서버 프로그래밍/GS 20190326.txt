멀티쓰레드


하나의 프로그램의 여러 곳이 동시 다발적으로 실행되는 프로그래밍 기법

병렬처리 프로그래밍 기법



병렬 처리
	하나의 작업을 여러 개의 콘텍스트에서 수행하는것 (콘텍스트 => PC 프로그램 카운터)


	한대 컴퓨터	
		SMP : 여러 개의 CPU
		Multi-Core : 여러 개의 core









왜 병렬처리를 하는가?

	한 개의 CPU의 처리 속도가 너무 느리기 때문

	Game Server는 20년 전부터 병렬 처리

	콜백함수를 더 자주 호출해야하는데 그러려면 더 빠른 cpu사용해야함
	
	발열의 한계에 부딪친 클럭 증가

	Game Server는 20년 전부터 병렬처리



프로세스 : 실행 중인 프로그램
	하나의 프로세스는 하나의 실행파일에서 출발

쓰레드 : 프로그램 실행의 흐름
	프로세스 실행 중 프로그램이 의도적으로 쓰레드 생성



멀티쓰레드 그림 보기
	SP는 각자의 영역 (지역변수는 다 따로)
	PC는 공유	CODE부분 (전역변수는 다 공유)




지역변수도 강제로 공유 가능은 하지만 그러지말자



장점
	성능 향상
	빠른 응답 속도
	더 나은 자원 활용
	프로세스보다 효율적인
		통신 (공유 메모리) 프로세스끼리 통신은 커널 recv send라 시스템 콜임 오버헤드
		context switch

위험
	프로그램 복잡도 증가
	디버깅의 어려움 (data race, deadlock)
	백만번 실행하면 1번 죽는다? 디버깅 불가능



게임 서버에서 멀티 쓰레드 사용하는 이유 
	동접 늘리기위해
	빠른 응답 속도를 위해서
		작업의 길이 차이






두 종류의 프로그래밍 스타일

	Heterogeneous
		작업을 쪼개서 종류별로 다른 쓰레드에게 맡기는 스타일

	Homogenous (event driven, data driven)
		작업을 쪼개서 쓰레드 구분 없이 나누어 하는 스타일

	Game 서버는 Homogeneous
		게이머 하나를 한 조각의 작업으로 생각
		동접 5000이면 5000개의 조각

	Client는 Heterogeneous
		렌더링 쓰레드, 물리 엔진 쓰레드, 장면 구성 쓰레드,




주의점

	쓰레드의 개수가 많다고 좋은 것이 아니다
	프로세서/코어의 개수에 맞추어라.
	운영체제 및 하드웨어에 부담 : Cache


	Data Race
		내가 사용하는 메모리의 내용이 내가 아닌 다른 쓰레드에 의해서 변경 될 수 있음을 항상 유념
		Single Core computer도 마찬가지
	

	디버깅이 어려움




Windows에서의 멀티 쓰레드 프로그래밍
	기본 지원
	사실상 멀티쓰레드에 특화된 OS
	추가 헤더나 라이브러리 필요 x
	쓰레드를 멀티코어에 잘 분배
		Affinity 적용 (결합성, 쓰레드를 임의 배정해주는 기능, 운영체제가 알아서 다해줌)



	쓰레드 문맥 전환
		x86 CPU에 쓰레드 전환 명령어 존재
		윈도우의 스케쥴러가 알아서 해줌


	Windows 고유의 API 존재하지만 C++11의 표준을 따르는 프로그래밍 방식 권장




쓰레드 만들기
	#include <thread>
	
	std::thread t1 {mythread};


	void mythread()
	{
		// 쓰레드가 실행할 프로그램
	}




쓰레드 종료 검사
	std::thread t1 {mythread};
	t1.join(); // t1쓰레드가 종료되길 기다림
			// 이걸 안해주면 메인이 끝나니까 프로세스가 종료됨


		
	


		
멀티 쓰레드 프로그램의 성능 측정

	High_resolution_clock으로 성능 측정

	모든 성능 측정은 릴리즈 모드로






register volatile
두개

register하면 레지스터에 적고 메모리에 안넣고 사라짐

volatile은 무조건 메모리에 적고 레지스터에 올리지않음



























