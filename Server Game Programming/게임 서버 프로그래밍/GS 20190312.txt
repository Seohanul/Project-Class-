

게임서버 운영체제

	서버용 운영체제의 종류

	리눅스
	가격이 저렴하다
	유지 보수 관리가 어렵다. (잘 아는 사람이 필요하다)


	윈도우즈계열
	비싸다.
	유지 보수 관리가 비교적 쉽다.


성능은 거기서 거기
	가격으로 결정, 리눅스는 공짜(작은 회사들, 작은 이익 게임)

	서버에서는 WINDOWS10 불가능
	서버용 윈도우 Windows2012, 2016 ~
		커널은 똑같은데 패키지가 다름
		편의성을 위한 기능들, 서버에서 필요없는 기능들 다 없앰
		메모리 ,cpu 절약

	cpu 2개 이상 사용하려면 서버 윈도우 사용해야함
	가격을 10배 뻥튀기함
	윈도우10은 그냥 1개밖에 안됨








** ppt 옛날거에는 없ㅇ름**
프로그램 최적화

	1. 꼭 필요한 일만 하기
		- 시스템 호출 최소화(new/delete 포함) **    (file I/O, NW I/O , 메모리 관리)
			delete 하지말고 list에 보관해뒀다가 
			필요할때 보관해놨던거 써라 (free list)

	2. 좋은 알고리즘 사용하기, O() 성능 좋은거
		

	3. 메모리 복사 줄이기
		- Call by value 대신 Call by reference
		- Copy Constructor 사용 회피 (이동 생성자나, emplace 써야함)
	
	4. HW 영향 고려
		- 캐시, 파이프라인

	5. 멀티쓰레드 프로그래밍






실제 예제 ** ppt 다름 **

		시스템 call 했을때 얼마나 느려지는가

천만번 루프 돌면서 더하는데 시스템콜함
	운영체제에서 아무것도 안하고 리턴하는 코드


시스템콜 부분 있고 없고가 400배~500배 느려짐
아무것도 안하는 시스템 콜이여도 이정도로 느림







**Cache Miss

	루프 돌면서
	배열에서 값을 읽어오는데,
	배열의 크기를 점점 바꿔보면서 진행함

	


1M, 2M, 4M, 8M까지는 400~500msecs 로 비슷한데

16M 부터는 실행속도가 엄청 늘어남

캐시의 사이즈 보다 배열이 커지면 캐시미스 늘어남




** Pipeline Stall

조건부 분기와 분기 예측 실패



static long abs(long x) {
	long y;
	y = x>>31; /* Not portable */
		return (x^y)-y;
}

2의보수 컴퓨터에서 절대값 계산하는 함수

x가 양수면 y 0나오고 그대로 x나옴

x가 음수면
y 1111111~ .. 1 이 나옴 (>> 연산 정의)
x^y x의 모든 비트가 거꾸로
 -1 해줌



인라인함수랑
어떤게 더 빠를것인가
	함수 만든게 훨씬 더 빠름

인라인은 Pipeline Stall이 있음
	mov ax, arr[bx]
	cmp ax, 0
	jge plus 		// jump greater than equal ** // 조건부 브랜치 명령 , 어디로 갈지 모르니까 그냥 찍음 (분기 예측),
					 실패하면 ? 다시 처음부터 해야함. 이게 (Pipeline Stall) 
	neg ax   //부호 바꾸기

plus : add[tmp] , ax








정리

	게임서버 최적화는 HW를 고려해야한다.
	-컴구에서 배운 것을 실제로 고려해야한다.
	- System Call 하지 말기
	- Cache 잘 사용하기
		* 가능하면 메모리 적게 사용하기
	-Multi-Thread Programming (다음달에..)





-----------------------------------

3장 네트워크기초

	3가지만 알면됨
		컴퓨터 네트워크
		패킷
		소켓



컴퓨터 네트워크란?
	이더넷 와이파이 블루투스 3G 4G..


네트워크 : 연결
		데이터를 주고 받음.
		이 데이터의 format이 뭐냐? ->패킷


패킷이란?
	데이터 주고받을때 그 데이터의 format
	

	Easy Error detection
	Host addressing 데이터를 묶어서 주소를 붙여서 보냄 
	Line sharing 여러 컴퓨터가 선을 공유함





Packet in Game
	TCP, UDP 패킷의 크기와는 관계없고
	프로그래머가 지정해서 패킷크기를 정해야함
	패킷 종류 수십개에 크기도 각각 다름

	send했을때 한 패킷이 recv 한번에 들어오지 않음

	즉 네트워크 packet과는 다른 이야기



	패킷의 맨앞에 길이, 타입이 있어야함
	


	채팅 패킷
		누구한테, 어떤 메세지를 보내는지
	
	무브 패킷
		위치, 속도, 가속도 등등 

			
배열로 하는방식  (읽기 어려움, 길이를 미리 알 수 없음 유연성이 떨어짐, 호환은 됨)
구조체로 하는방식 (읽기 쉽고 , 실행하기 편함, 호환성이 없음 (cpu, os, 언어 바뀌면 된다는 보장이 없음 , ex 유니티는 c# 이므로 struct 안됨) )

취향임



프로토콜 정의만 해두면 서버팀 클라팀 만날일 없음







** 소켓






4장

네트워크 프로그래밍 단계
	클라
		소켓생성(Socket)
		서버 소켓 연결(Connect)
		Data 송/수신 (Recv/Send)
		소켓 끊기

	서버
		소켓 생성(Socket)
		소켓 묶기(Bind)
		소켓 접속 대기(listen)
		연결 소켓 생성(Accept)
		Data 송/수신 (Recv/Send)
		소켓 끊기(Close)




Windows에서는 Winsock을 사용
	- Winsock 2,0 사용할 예정

	- WSAStartup(), WSACleanup()필요

유닉스가 오리지날
BSD 4.2





소켓만들기
~!~


TCP, UDP

쭉 다 읽어보기





Sockaddr 지정방법

다 넷겜플때 배운건데 안다는 가정하에 넘어가는중
다 읽어보고 복습해야함




htons



***
dwBurrerCount   ,  IpNumberofBytesRevcd
 버퍼의 갯수		받은 데이터의 크기
***



WSABUF **

	흩어진 데이터를 관리하는 구조
	성능 저하의 주범인 데이터 복사를 줄여줌

	버퍼 여러개를 구조체로 묶어놓은거임

	




서버가 클라이언트와 다른점
	누가 연결 할 지 모른다.
	여러 개의 연결을 관리해야한다.

	해결
		연결을 관리하는 소켓을 따로 둔다.
		외부에서 오는 연결 신청을 받는 API를 사용한다.
		연결이 성공될 때 마다 새로운 소켓을 만든다.



Socket 접속 대기
	int listen (SOCKET s, int backlog)

		backlog : 접속 대기 큐의 최대 연결 가능 숫자
			우리는 대규모니까 SOMAXCONN 해야함




연결 Socket 생성
	Accept



















		
