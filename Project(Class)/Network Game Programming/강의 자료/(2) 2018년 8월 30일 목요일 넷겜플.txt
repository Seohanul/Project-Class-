네트워크와 소켓 프로그래밍




인터넷 구성 요소

라우터 : 목적지까지 최적의 경로를 찾아서 데이터를 전송해주는 장치

호스트 - 라우터 - 인터넷

호스트 : app을 담고있는 컴퓨터


호스트 : 최종 사용자의 응용프로그램을 수행하는 주체

라우터 : 호스트에서 생성된 데이터를 여러 네트워크를 거쳐 전송함으로써 서로 다른 네트워크에 속한 호스트 간에 데이터를 교환할 수 있게 하는 장비

통신 프로토콜 : 호스트와 라우터, 라우터와 라우터, 호스트와 호스트가 통신하기 위한 정해진 절차와 방법


TCP/IP 프로토콜 :
		운영체제의 일부로 구현 ***** 중요

		응용 프로그램은 운영체제가 제공하는 TCP/IP 프로토콜의 서비스를 사용해 통신

		운영체제에 다 구현되어있으니 애플리케이션에서 가져다 쓰면됨 


호스트 안에 운영체제가 있고 그 위에 애플리케이션이 있음

기능을 불러서 쓰는거에 불과함



TCP/IP 구조
	4개 계층
		애플리케이션 계층
		전송 계층
		인터넷 계층
		네트워크 액세스 계층


네트워크 액세스 계층
	물리적 네트워크 (망, 전송 매체)를 통한 실제적인 데이터 전송

	네트워크 하드웨어 + 디바이스 

	Mac address 물리 주소를 이용해서 주소 지정


인터넷 계층
	네트워크 계층의 도움(라우터)을 받아 데이터를 호스트까지 전달

	IP주소(논리적인 식별주소) + 라우터

	접속하는 동안 IP주소는 유일해야함, 그래서 논리주소

	목적지까지 데이터를 전달하기위한 작업 : 라우팅
		우체부가 주소를 찾아와서 편지를 꽂는거까지
		누가받아야할지는 수신인이 써있음 (포트번호로 구분)

전송 계층 
	목적지 까지 도달한 데이터를 어떤 애플리케이션까지 전달해야할지 결정함 (포트번호 이용)
	ex) TCP, UDP

		**텀프로젝트에 설계가 중요함 설계를 못하면 시작못함
			tcp로할지 udp로 할지 처음에 정해야함
			나중에 바꾸면 맨처음부터 다시해야하므로 
			처음에 설계를 잘해야함


	

TCP와 UDP

TCP는 연결형 프로토콜  UDP는 비연결형 프로토콜
	비연결이라는 말이 두개의 호스트가 연결이 안되어있다는 얘기가아니라
	연결 설정을 안해도 된다는 말
	핸드쉐이크 : 보낼껀데 받을 준비됐니? -> 응 됐어 -> 그럼 보낼게 
			연결하기 전에 주고받는거

	UDP는 핸드쉐이크 없이 그냥 보냄, 받을 준비가 되어있는지 관심없음
	그냥 나중에 받은쪽이 받을 준비가 되면 받는거임

	TCP는 데이터 경계를 구분하지 않음 - 바이트 스트림(byte-stream)서비스

	UDP는 데이터 경계를 구분함 -데이터그램(datagram) 서비스


	연결형 :  전화통화, 1대1, 신뢰성, 데이터 재전송
	비연결형 : 이메일, 1대1, 1대다, 다대다 가능, 신뢰이 담보되지않음, 재전송x (깨진데이터가 있으면 걍 버려버림)


만약 로그인때 udp를 사용하면 udp는 깨진 정보를 버리기때문에 그 정보를 체크하는거를 프로그래머가 해야함

TCP가 멀티쓰레드를 사용해야함, UDP는 안써도됨 그러니까 udp를 사용하려는 유혹이 생길거임



                                                                                                                         

응용계층

	게임을 위해 미리 만들어진 프로토콜이 없음
	그러니 이번학기 가장 중요한게 데이터를 어떻게 주고받을지 설계하는게 가장 중요

	어떤게임은 로그인을 8글자까지만 할수도있고 12글자로 할수도있고 이런것들 정하는거임




패킷
	각각의 프로토콜에서 정의한 제어정보(부가정보) + 데이터
	부가 정보들이 앞뒤로 붙음
	앞 헤더 뒤 트레일러
	부가정보 (IP주소, 포트번호, 오류체크코드)

	패킷 전송형태
		애플리케이션 - 로그인 데이터
		전송	 - 포트번호 + 데이터
		인터넷 - IP + 포트번호 + 데이터
		네트워크 - 맥 + IP +포트 + 데이터

하나씩 붙으면서 내려감
올라올때는 반대로


라우터에서는 전체를 받은후 IP헤더를 식별해서 어느방향으로 보낼지 찾아서 이동시킴




IP 주소
	인터넷에 존재하는 호스트를 구별하는 식별자
	IPv4는 32 , IPv6는 128 두개 혼용
	수업때는 4위주로

포트번호
	통신 종착지 (하나 혹은 여러개의 프로세스)를 나타내는 식별자
	여러 애플리케이션 중에 어느 애플리케이션에 보내야하는지를 식별할 수 있는 
	0~65535
	포트번호 원래 있는건 쓰면 안돼고 새로 만든건 없는 곳꺼를 가져다 써야함



	IP주소는 집주소 포트번호는 수신인


도메인 이름 
	IP 주소에 대한 별명
	실제 통신을 하려면 IP주소로 변환해야함


클라이언트/서버 모델
	두개의 애플리케이션이 상호 작용하는 방식을 나타냄

	클라이언트가 서버에게 요청* 을 하면 서버는 이 요청을 받아 처리

	클라이언트도 요청하려면 서버를 알아야함



소켓
	뭔가를 꽂을 수 있는 틀
	운영체제에서 지원해주는 틀 (필요할때 만들고 필요없으면 없애면됨)
	c언어 파일생성과 유사
	SOCKET s = socket(~);
	recv(sock, ~) //받기
	send(sock, ~) //보내기

	운영체제가 통신을 위해 관리하는 데이터를 간접적으로 참조할 수 있도록 만든 일종의 핸들


	응용프로그램은 잔신의 소켓이 상대편의 소켓과 연결된 것으로 생각하고 데이터를 주고받음
	두 호스트가 물리적으로 떨어져있는데 내가 보내고자 하는 데이터를 소켓에 집어넣고 send하면 바로 상대 소켓에 들어간다고 생각

	통신 양단이 모두 소켓을 사용할 필요는 없음.
	애플리케이션 계층과 전송계층 사이에서 가교역할을 함



소켓에다 데이터를 넣고 운영체제에 보내면 이것저것 김히동 시체 붙여서 패킷이 되는거임
TCP소켓과 UDP소켓은 다르게생김 만들때 결정





윈도우 소켓
	버클리 유닉스에서 베껴옴
	유닉스 소켓과의 차이점
		윈도우는 dll을 통해 대부분의 기능이 제공되므로 dll초기화, 종료작업을 위한 함수가 필요

		윈도우는 메시지드리븐이므로 이를 위한 확장 함수가 존재
			이벤트가 일어나면 큐에 들어가고 큐에 있는거를 하나씩 처리해주는 방식

		윈도우는 운영체제에서 멀티스레드를 지원하므로 멀티스레드에서 안정적으로 동작하기위한 구조와 이를 위한 함수가 필요
		유닉스에서는 CPU가 여러개기 때문에 그럴필요없음. 

윈속 장점 유닉스에서 베껴왔기 때문에 의미없음

	단점
		애플리케이션 수준의 프로토콜을 프로그래머가 직접 설계해야함
		(데이터를 어떻게 주고받을지 약속해야함) 근데 유닉스도 똑같음

		진짜단점
		서로 다른 바이트 정렬방식을 사용하거나 데이터 처리단위가 서로 다른 종단 시스템간 통신을 할 경우,
		애플리케이션 수준에서 데이터 변환을 처리해야함
		어떤 CPU는 데이터를 앞에서 부터 쓰고, 어떤CPU는 뒤에서부터 씀
	
	